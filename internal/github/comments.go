package github

import (
	"fmt"
	"regexp"
	"strings"
)

// ManfredMeta contains metadata extracted from a Manfred comment.
type ManfredMeta struct {
	SessionID string
	Phase     string
}

var (
	// Pattern to match Manfred comment metadata
	manfredMetaPattern = regexp.MustCompile(`<!-- manfred:session:([^:]+):phase:([^ ]+) -->`)

	// Patterns for approval keywords
	defaultApprovalPatterns = []string{
		`@claude\s+approved?`,
		`@claude\s+lgtm`,
		`@claude\s+go\s+ahead`,
		`/approve`,
	}
)

// FormatComment creates a Manfred-identifiable comment.
func FormatComment(sessionID, phase, content string) string {
	return fmt.Sprintf(`<!-- manfred:session:%s:phase:%s -->

%s

---

<sub>Reply with `+"`@claude approved`"+` to start implementation, or provide feedback.</sub>`,
		sessionID, phase, content)
}

// FormatPlanComment creates a comment for posting an implementation plan.
func FormatPlanComment(sessionID, plan string) string {
	return FormatComment(sessionID, "planning", fmt.Sprintf(`## Implementation Plan

%s`, plan))
}

// FormatErrorComment creates a comment for posting an error.
func FormatErrorComment(sessionID, phase, errorMsg string) string {
	return fmt.Sprintf(`<!-- manfred:session:%s:phase:%s:error -->

## Error

An error occurred during the **%s** phase:

`+"```"+`
%s
`+"```"+`

<sub>You can retry by commenting `+"`@claude retry`"+`.</sub>`,
		sessionID, phase, phase, errorMsg)
}

// FormatPRDescription creates a PR body with session metadata.
func FormatPRDescription(sessionID string, issueNumber int, summary string) string {
	return fmt.Sprintf(`<!-- manfred:session:%s:pr -->

%s

---

Closes #%d

<sub>Generated by [MANFRED](https://github.com/mpm/manfred)</sub>`,
		sessionID, summary, issueNumber)
}

// ParseManfredComment extracts metadata from a comment body.
// Returns nil if the comment is not a Manfred comment.
func ParseManfredComment(body string) *ManfredMeta {
	matches := manfredMetaPattern.FindStringSubmatch(body)
	if len(matches) != 3 {
		return nil
	}
	return &ManfredMeta{
		SessionID: matches[1],
		Phase:     matches[2],
	}
}

// IsManfredComment checks if a comment was posted by Manfred.
func IsManfredComment(body string) bool {
	return manfredMetaPattern.MatchString(body)
}

// IsApproval checks if a comment contains an approval keyword.
func IsApproval(body string) bool {
	lower := strings.ToLower(body)
	for _, pattern := range defaultApprovalPatterns {
		re := regexp.MustCompile(`(?i)` + pattern)
		if re.MatchString(lower) {
			return true
		}
	}
	return false
}

// IsRetryRequest checks if a comment requests a retry.
func IsRetryRequest(body string) bool {
	lower := strings.ToLower(body)
	patterns := []string{
		`@claude\s+retry`,
		`/retry`,
	}
	for _, pattern := range patterns {
		re := regexp.MustCompile(`(?i)` + pattern)
		if re.MatchString(lower) {
			return true
		}
	}
	return false
}

// ExtractFeedback extracts user feedback from a comment, excluding metadata.
func ExtractFeedback(body string) string {
	// Remove HTML comments
	htmlCommentPattern := regexp.MustCompile(`<!--[\s\S]*?-->`)
	cleaned := htmlCommentPattern.ReplaceAllString(body, "")

	// Remove the footer
	footerPattern := regexp.MustCompile(`(?s)---\s*<sub>.*</sub>\s*$`)
	cleaned = footerPattern.ReplaceAllString(cleaned, "")

	return strings.TrimSpace(cleaned)
}
